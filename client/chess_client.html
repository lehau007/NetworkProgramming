<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Client</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #333;
            color: #fff;
        }

        .container {
            display: flex;
            gap: 20px;
            perspective: 1000px;
        }

        .panel {
            background-color: #444;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.5s, opacity 0.5s;
            width: 350px;
        }

        .hidden {
            display: none;
            opacity: 0;
            transform: rotateY(-30deg) scale(0.9);
        }

        h2 {
            text-align: center;
            color: #4CAF50;
            margin-bottom: 20px;
        }

        input[type="text"],
        input[type="password"],
        input[type="email"] {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 15px;
            border: none;
            border-radius: 5px;
            background-color: #555;
            color: #fff;
        }

        button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 5px;
            background-color: #4CAF50;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            margin-top: 10px;
        }

        button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        #chessboard {
            width: 480px;
            height: 480px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            border: 4px solid #666;
            border-radius: 8px;
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 48px;
            transition: background-color 0.2s;
        }

        .light {
            background-color: #f0d9b5;
        }

        .dark {
            background-color: #b58863;
        }

        .piece {
            cursor: pointer;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .piece.white-piece {
            color: #ffffff;
            text-shadow: 
                1px 1px 0 #000,
                -1px 1px 0 #000,
                1px -1px 0 #000,
                -1px -1px 0 #000,
                0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .piece.black-piece {
            color: #1a1a1a;
            text-shadow: 
                1px 1px 0 #666,
                -1px 1px 0 #666,
                1px -1px 0 #666,
                -1px -1px 0 #666,
                0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .selected {
            background-color: yellow !important;
        }

        .in-check {
            background-color: #ff5252 !important;
            box-shadow: 0 0 20px rgba(255, 82, 82, 0.8) inset;
            animation: pulse-check 1s infinite;
        }

        @keyframes pulse-check {

            0%,
            100% {
                box-shadow: 0 0 20px rgba(255, 82, 82, 0.8) inset;
            }

            50% {
                box-shadow: 0 0 30px rgba(255, 82, 82, 1) inset;
            }
        }

        #player-list div {
            padding: 8px;
            border-bottom: 1px solid #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #player-list button {
            width: auto;
            padding: 5px 10px;
            font-size: 14px;
            margin-top: 0;
        }

        #messages {
            height: 250px;
            overflow-y: auto;
            border: 1px solid #555;
            padding: 10px;
            margin-bottom: 15px;
            background-color: #3a3a3a;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }

        .message {
            padding: 5px;
            border-radius: 3px;
        }

        .system {
            color: #ffab40;
        }

        .sent {
            color: #81d4fa;
        }

        .received {
            color: #c5e1a5;
        }

        #game-state p {
            margin: 5px 0;
        }

        /* User Profile Card */
        .user-profile {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .user-profile h3 {
            margin: 0 0 15px 0;
            color: #fff;
            font-size: 20px;
            text-align: center;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }

        .user-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-box {
            background-color: rgba(255, 255, 255, 0.15);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
        }

        .stat-box.rating {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .stat-box.rating .stat-value {
            font-size: 32px;
        }

        /* Game Log Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background-color: #444;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #666;
            padding-bottom: 15px;
        }

        .modal-header h2 {
            margin: 0;
            color: #4CAF50;
        }

        .modal-close {
            background: #ff5252;
            border: none;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
        }

        .game-result {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .game-result.win {
            background: linear-gradient(135deg, #4CAF50, #45a049);
        }

        .game-result.loss {
            background: linear-gradient(135deg, #f44336, #d32f2f);
        }

        .game-result.draw {
            background: linear-gradient(135deg, #ff9800, #f57c00);
        }

        .game-result h3 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }

        .game-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .game-info-item {
            background-color: #555;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .game-info-label {
            color: #aaa;
            font-size: 12px;
            text-transform: uppercase;
        }

        .game-info-value {
            color: #fff;
            font-size: 16px;
            font-weight: bold;
        }

        .move-history {
            background-color: #333;
            padding: 15px;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .move-history h4 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }

        .moves-grid {
            display: grid;
            grid-template-columns: 30px 1fr 1fr;
            gap: 5px;
            font-family: 'Courier New', monospace;
        }

        .move-number {
            color: #888;
            text-align: right;
        }

        .move-white, .move-black {
            padding: 3px 8px;
            border-radius: 3px;
        }

        .move-white {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .move-black {
            background-color: rgba(0, 0, 0, 0.3);
        }

        /* Duplicate Session Alert */
        .duplicate-session-alert {
            background: linear-gradient(135deg, #ff5252, #d32f2f);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 20px;
        }

        .duplicate-session-alert h3 {
            margin: 0 0 10px 0;
        }

        .duplicate-session-alert p {
            margin: 0;
            opacity: 0.9;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Login Section -->
        <div id="login-section" class="panel">
            <h2>Login</h2>
            <input type="text" id="username" placeholder="Username">
            <input type="password" id="password" placeholder="Password">
            <button onclick="login()">Login</button>
            <button onclick="showRegister()">Register</button>
        </div>

        <!-- Register Section -->
        <div id="register-section" class="panel hidden">
            <h2>Register</h2>
            <input type="text" id="reg-username" placeholder="Username">
            <input type="password" id="reg-password" placeholder="Password">
            <input type="email" id="reg-email" placeholder="Email">
            <button onclick="register()">Register</button>
            <button onclick="showLogin()">Back to Login</button>
        </div>

        <!-- Lobby Section -->
        <div id="lobby-section" class="panel hidden">
            <h2>Lobby</h2>

            <!-- User Profile Card -->
            <div class="user-profile">
                <h3>üèÜ <span id="profile-username">Player</span></h3>
                <div class="user-stats">
                    <div class="stat-box rating">
                        <div class="stat-label">Rating</div>
                        <div class="stat-value" id="profile-rating">1200</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Wins</div>
                        <div class="stat-value" id="profile-wins">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Losses</div>
                        <div class="stat-value" id="profile-losses">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Draws</div>
                        <div class="stat-value" id="profile-draws">0</div>
                    </div>
                </div>
            </div>

            <div id="player-list"></div>
            <button onclick="getAvailablePlayers()">Refresh Players</button>
            <button onclick="logout()">Logout</button>
        </div>

        <!-- Game Section -->
        <div id="game-section" class="hidden">
            <div class="panel">
                <div id="chessboard"></div>
            </div>
            <div class="panel">
                <h2>Game Info</h2>
                <div id="game-state"></div>
                <div id="messages"></div>
                <button onclick="resign()">Resign</button>
                <button onclick="offerDraw()">Offer Draw</button>
            </div>
        </div>

        <!-- Game Log Modal -->
        <div id="game-log-modal" class="modal-overlay">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>üèÅ Game Over</h2>
                    <button class="modal-close" onclick="closeGameLogModal()">√ó</button>
                </div>
                <div id="game-result-section" class="game-result">
                    <h3 id="result-title">Result</h3>
                    <p id="result-reason">Reason</p>
                </div>
                <div class="game-info">
                    <div class="game-info-item">
                        <div class="game-info-label">White</div>
                        <div class="game-info-value" id="log-white-player">-</div>
                    </div>
                    <div class="game-info-item">
                        <div class="game-info-label">Black</div>
                        <div class="game-info-value" id="log-black-player">-</div>
                    </div>
                    <div class="game-info-item">
                        <div class="game-info-label">Moves</div>
                        <div class="game-info-value" id="log-move-count">0</div>
                    </div>
                    <div class="game-info-item">
                        <div class="game-info-label">Duration</div>
                        <div class="game-info-value" id="log-duration">0:00</div>
                    </div>
                </div>
                <div class="move-history">
                    <h4>üìú Move History</h4>
                    <div id="moves-grid" class="moves-grid">
                        <!-- Moves will be inserted here -->
                    </div>
                </div>
                <button onclick="closeGameLogModal()" style="margin-top: 20px;">Return to Lobby</button>
            </div>
        </div>

        <!-- Duplicate Session Modal -->
        <div id="duplicate-session-modal" class="modal-overlay">
            <div class="modal-content">
                <div class="duplicate-session-alert">
                    <h3>‚ö†Ô∏è Session Already Active</h3>
                    <p id="duplicate-session-message">Another connection is using this session.</p>
                </div>
                <p style="text-align: center; color: #aaa;">
                    You cannot have multiple browser tabs/windows using the same session.
                    Please close the other connection or log in with different credentials.
                </p>
                <button onclick="closeDuplicateSessionModal()">Close</button>
                <button onclick="forceNewLogin()" style="background-color: #ff9800;">Login with New Session</button>
            </div>
        </div>
    </div>

    <script>
        const wsUrl = "ws://localhost:8080";
        let ws = null;
        let session_id = null;
        let username = null;
        let currentGameId = null;
        let userData = null; // Store user data from server
        let myColor = null; // Store player's color ("white" or "black")

        // UI Elements
        const loginSection = document.getElementById('login-section');
        const registerSection = document.getElementById('register-section');
        const lobbySection = document.getElementById('lobby-section');
        const gameSection = document.getElementById('game-section');
        const messagesDiv = document.getElementById('messages');

        // Function to update user profile display
        function updateUserProfile(data) {
            if (!data) return;

            userData = data;
            document.getElementById('profile-username').textContent = data.username || 'Player';
            document.getElementById('profile-rating').textContent = data.rating || '1200';
            document.getElementById('profile-wins').textContent = data.wins || '0';
            document.getElementById('profile-losses').textContent = data.losses || '0';
            document.getElementById('profile-draws').textContent = data.draws || '0';
        }

        // Function to reload user profile from server
        function reloadUserProfile() {
            if (!session_id || !userData || !userData.user_id) return;

            // Request fresh user data from server
            // According to MESSAGE_TYPES.md, we can use VERIFY_SESSION to get updated user_data
            send({ type: 'VERIFY_SESSION', session_id: session_id });
        }

        // UI Navigation
        function showLogin() {
            loginSection.classList.remove('hidden');
            registerSection.classList.add('hidden');
            lobbySection.classList.add('hidden');
            gameSection.classList.add('hidden');
        }

        function showRegister() {
            loginSection.classList.add('hidden');
            registerSection.classList.remove('hidden');
            lobbySection.classList.add('hidden');
            gameSection.classList.add('hidden');
        }

        function showLobby() {
            loginSection.classList.add('hidden');
            registerSection.classList.add('hidden');
            lobbySection.classList.remove('hidden');
            gameSection.classList.add('hidden');
        }

        function showGame() {
            loginSection.classList.add('hidden');
            registerSection.classList.add('hidden');
            lobbySection.classList.add('hidden');
            gameSection.classList.remove('hidden');
        }

        function addMessage(text, type = 'system') {
            const messageDiv = document.createElement('div');
            messageDiv.textContent = text;
            messageDiv.className = type;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function connect() {
            if (ws) {
                ws.close();
            }
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                addMessage("Connected to server.", 'system');
                // If we have a session ID, try to verify it
                const saved_session = localStorage.getItem('session_id');
                if (saved_session) {
                    session_id = saved_session;
                    username = localStorage.getItem('username');
                    send({ type: 'VERIFY_SESSION', session_id: session_id });
                } else {
                    showLogin();
                }
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                addMessage(`Received: ${event.data}`, 'received');
                handleMessage(msg);
            };

            ws.onclose = () => {
                addMessage("Disconnected from server.", 'system');
                ws = null;
                showLogin();
            };

            ws.onerror = (error) => {
                addMessage("WebSocket error.", 'system');
                console.error("WebSocket Error: ", error);
            };
        }

        function send(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const msgString = JSON.stringify(data);
                ws.send(msgString);
                addMessage(`Sent: ${msgString}`, 'sent');
            } else {
                addMessage("Not connected to server.", 'system');
            }
        }

        function handleMessage(msg) {
            switch (msg.type) {
                case 'SESSION_VALID':
                    session_id = msg.session_id;
                    username = msg.user_data.username;
                    localStorage.setItem('session_id', session_id);
                    localStorage.setItem('username', username);

                    // Update user profile with fresh data
                    updateUserProfile(msg.user_data);

                    showLobby();
                    getAvailablePlayers();
                    break;
                case 'SESSION_INVALID':
                    localStorage.removeItem('session_id');
                    localStorage.removeItem('username');
                    session_id = null;
                    username = null;
                    showLogin();
                    break;
                case 'DUPLICATE_SESSION':
                    // Handle duplicate session - another connection is using this session
                    addMessage(`‚ö†Ô∏è Duplicate session: ${msg.message}`, 'system');
                    showDuplicateSessionModal(msg.message);
                    break;
                case 'LOGIN_RESPONSE':
                    if (msg.status === 'success') {
                        session_id = msg.session_id;
                        username = msg.user_data.username;
                        localStorage.setItem('session_id', session_id);
                        localStorage.setItem('username', username);

                        // Update user profile with data from login
                        updateUserProfile(msg.user_data);

                        showLobby();
                        getAvailablePlayers();
                    } else {
                        alert(`Login failed: ${msg.message}`);
                    }
                    break;
                case 'REGISTER_RESPONSE':
                    if (msg.status === 'success') {
                        alert('Registration successful! Please login.');
                        showLogin();
                    } else {
                        alert(`Registration failed: ${msg.message}`);
                    }
                    break;
                case 'DRAW_OFFER_RECEIVED':
                    if (confirm('Your opponent has offered a draw. Do you accept?')) {
                        respondToDrawOffer(true);
                    } else {
                        respondToDrawOffer(false);
                    }
                    break;
                case 'MOVE_ACCEPTED':
                    // Update board state if provided
                    if (msg.board_state) {
                        renderPieces(msg.board_state);
                    }
                    // Update game state display
                    if (msg.current_turn) {
                        updateTurnDisplay(msg.current_turn);
                    }
                    // Check if opponent is in check (we just moved)
                    if (msg.is_check && msg.current_turn) {
                        // current_turn is the next player (opponent)
                        // Only highlight if opponent is in check, not us
                        highlightKingInCheck(msg.current_turn);
                        addMessage('‚ö†Ô∏è CHECK! Opponent\'s king is under attack!', 'system');
                    } else {
                        clearCheckHighlight();
                    }
                    break;
                case 'MOVE_REJECTED':
                    alert(`‚ùå Move rejected: ${msg.reason}`);
                    // Clear selection on rejected move
                    if (selectedSquare !== null) {
                        const square = document.querySelector(`.square[data-index='${selectedSquare}']`);
                        if (square) square.classList.remove('selected');
                        selectedSquare = null;
                    }
                    break;
                case 'GAME_ENDED':
                    // Show game log modal with full game details
                    showGameLogModal(msg);

                    // Reload user profile to get updated stats (wins/losses/draws/rating)
                    setTimeout(() => {
                        reloadUserProfile();
                    }, 500);
                    break;
                case 'PLAYER_LIST':
                    const playerListDiv = document.getElementById('player-list');
                    playerListDiv.innerHTML = '<h3>Available Players</h3>';
                    msg.players.forEach(player => {
                        if (player.username !== username) {
                            const playerDiv = document.createElement('div');
                            
                            // Display player name, rating, and status
                            let statusText = '';
                            let statusColor = '';
                            if (player.status === 'in_game') {
                                statusText = ' [In Game]';
                                statusColor = 'color: #ff6b6b;';
                            } else if (player.status === 'busy') {
                                statusText = ' [Busy]';
                                statusColor = 'color: #ffa500;';
                            } else {
                                statusText = ' [Available]';
                                statusColor = 'color: #51cf66;';
                            }
                            
                            playerDiv.innerHTML = `<span>${player.username} (${player.rating})<span style="${statusColor}">${statusText}</span></span>`;
                            
                            const challengeButton = document.createElement('button');
                            challengeButton.textContent = 'Challenge';
                            challengeButton.onclick = () => challengePlayer(player.username);
                            
                            // Disable button if player is not available
                            if (player.status !== 'available') {
                                challengeButton.disabled = true;
                                challengeButton.style.cursor = 'not-allowed';
                                challengeButton.style.opacity = '0.5';
                            }
                            
                            playerDiv.appendChild(challengeButton);
                            playerListDiv.appendChild(playerDiv);
                        }
                    });
                    break;
                case 'CHALLENGE_RECEIVED':
                    const from = msg.from_username;
                    if (confirm(`You have received a challenge from ${from}. Do you accept?`)) {
                        send({ type: 'ACCEPT_CHALLENGE', session_id: session_id, challenge_id: msg.challenge_id });
                    } else {
                        send({ type: 'DECLINE_CHALLENGE', session_id: session_id, challenge_id: msg.challenge_id });
                    }
                    break;
                case 'MATCH_STARTED':
                    currentGameId = msg.game_id;
                    myColor = msg.your_color; // Save player's color
                    console.log(`Match started! I am playing as ${myColor}`);
                    // Recreate chessboard with correct orientation for this player
                    createChessboard();
                    showGame();
                    send({ type: 'GET_GAME_STATE', session_id: session_id, game_id: msg.game_id });
                    break;
                case 'GAME_STATE':
                    currentGameId = msg.game_id;
                    updateGameState(msg);
                    // Update turn display
                    if (msg.current_turn) {
                        updateTurnDisplay(msg.current_turn);
                    }
                    // Check for check status - only highlight if WE are in check
                    if (msg.is_check && msg.current_turn && msg.current_turn === myColor) {
                        highlightKingInCheck(myColor);
                        addMessage('‚ö†Ô∏è You are in CHECK!', 'system');
                    } else {
                        clearCheckHighlight();
                    }
                    showGame();
                    break;
                case 'OPPONENT_MOVE':
                    updateGameState(msg);
                    // Update turn display
                    if (msg.current_turn) {
                        updateTurnDisplay(msg.current_turn);
                    }
                    // Check if WE are in check (opponent just moved)
                    if (msg.is_check && msg.current_turn) {
                        // current_turn is the next player
                        // If current_turn matches our color, WE are in check
                        if (msg.current_turn === myColor) {
                            highlightKingInCheck(myColor);
                            addMessage('‚ö†Ô∏è You are in CHECK! You must defend your king!', 'system');
                        }
                    } else {
                        clearCheckHighlight();
                    }
                    break;
                default:
                    break;
            }
        }

        function resign() {
            send({
                type: 'RESIGN',
                session_id: session_id,
                game_id: currentGameId
            });
        }

        function offerDraw() {
            send({
                type: 'DRAW_OFFER',
                session_id: session_id,
                game_id: currentGameId
            });
        }

        function respondToDrawOffer(accepted) {
            send({
                type: 'DRAW_RESPONSE',
                session_id: session_id,
                game_id: currentGameId,
                accepted: accepted
            });
        }

        function challengePlayer(targetUsername) {
            send({
                type: 'CHALLENGE',
                session_id: session_id,
                target_username: targetUsername
            });
        }

        function login() {
            const user = document.getElementById('username').value;
            const pass = document.getElementById('password').value;
            if (!user || !pass) {
                alert('Please enter username and password');
                return;
            }
            send({
                type: 'LOGIN',
                username: user,
                password: pass
            });
        }

        function register() {
            const user = document.getElementById('reg-username').value;
            const pass = document.getElementById('reg-password').value;
            const email = document.getElementById('reg-email').value;
            if (!user || !pass) {
                alert('Please enter username and password');
                return;
            }
            send({
                type: 'REGISTER',
                username: user,
                password: pass,
                email: email
            });
        }

        function getAvailablePlayers() {
            if (!session_id) {
                alert('Not logged in');
                return;
            }
            send({
                type: 'GET_AVAILABLE_PLAYERS',
                session_id: session_id
            });
        }

        function logout() {
            if (session_id) {
                send({
                    type: 'LOGOUT',
                    session_id: session_id
                });
            }
            localStorage.removeItem('session_id');
            localStorage.removeItem('username');
            session_id = null;
            username = null;
            currentGameId = null;
            if (ws) {
                ws.close();
            }
            showLogin();
        }

        // ============================================
        // Game Log Modal Functions
        // ============================================
        function showGameLogModal(gameData) {
            const modal = document.getElementById('game-log-modal');
            const resultSection = document.getElementById('game-result-section');
            const resultTitle = document.getElementById('result-title');
            const resultReason = document.getElementById('result-reason');
            
            // Determine if player won, lost, or drew
            let resultClass = 'draw';
            let resultText = 'Draw!';
            
            if (gameData.result === 'WHITE_WIN' || gameData.result === 'BLACK_WIN') {
                if (gameData.winner === username) {
                    resultClass = 'win';
                    resultText = 'üéâ Victory!';
                } else {
                    resultClass = 'loss';
                    resultText = 'üòî Defeat';
                }
            } else {
                resultText = 'ü§ù Draw';
            }
            
            resultSection.className = 'game-result ' + resultClass;
            resultTitle.textContent = resultText;
            resultReason.textContent = formatReason(gameData.reason);
            
            // Fill game info
            document.getElementById('log-white-player').textContent = gameData.white_player || '-';
            document.getElementById('log-black-player').textContent = gameData.black_player || '-';
            document.getElementById('log-move-count').textContent = gameData.move_count || 0;
            document.getElementById('log-duration').textContent = formatDuration(gameData.duration_seconds || 0);
            
            // Fill move history
            const movesGrid = document.getElementById('moves-grid');
            movesGrid.innerHTML = '';
            
            if (gameData.move_history && gameData.move_history.length > 0) {
                for (let i = 0; i < gameData.move_history.length; i += 2) {
                    const moveNumber = Math.floor(i / 2) + 1;
                    const whiteMove = gameData.move_history[i] || '';
                    const blackMove = gameData.move_history[i + 1] || '';
                    
                    const numDiv = document.createElement('div');
                    numDiv.className = 'move-number';
                    numDiv.textContent = moveNumber + '.';
                    
                    const whiteDiv = document.createElement('div');
                    whiteDiv.className = 'move-white';
                    whiteDiv.textContent = whiteMove;
                    
                    const blackDiv = document.createElement('div');
                    blackDiv.className = 'move-black';
                    blackDiv.textContent = blackMove;
                    
                    movesGrid.appendChild(numDiv);
                    movesGrid.appendChild(whiteDiv);
                    movesGrid.appendChild(blackDiv);
                }
            } else {
                movesGrid.innerHTML = '<div style="grid-column: 1/-1; color: #888;">No moves recorded</div>';
            }
            
            modal.classList.add('show');
        }
        
        function closeGameLogModal() {
            const modal = document.getElementById('game-log-modal');
            modal.classList.remove('show');
            showLobby();
            getAvailablePlayers();
        }
        
        function formatReason(reason) {
            const reasons = {
                'checkmate': 'Checkmate',
                'resignation': 'Resignation',
                'timeout': 'Time Out',
                'draw_agreement': 'Draw by Agreement',
                'stalemate': 'Stalemate',
                'opponent_disconnected': 'Opponent Disconnected',
                'insufficient_material': 'Insufficient Material'
            };
            return reasons[reason] || reason || 'Game Over';
        }
        
        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // ============================================
        // Duplicate Session Modal Functions
        // ============================================
        function showDuplicateSessionModal(message) {
            const modal = document.getElementById('duplicate-session-modal');
            document.getElementById('duplicate-session-message').textContent = message || 'Another connection is using this session.';
            modal.classList.add('show');
        }
        
        function closeDuplicateSessionModal() {
            const modal = document.getElementById('duplicate-session-modal');
            modal.classList.remove('show');
            // Clear stored session since it's being used elsewhere
            localStorage.removeItem('session_id');
            localStorage.removeItem('username');
            session_id = null;
            username = null;
            if (ws) {
                ws.close();
            }
            showLogin();
        }
        
        function forceNewLogin() {
            closeDuplicateSessionModal();
            // Reconnect for a fresh login
            setTimeout(() => {
                connect();
            }, 500);
        }




        function createChessboard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';
            
            // Flip board if playing as black (black player sees board from their perspective)
            const isFlipped = (myColor === 'black');
            
            for (let displayPos = 0; displayPos < 64; displayPos++) {
                const square = document.createElement('div');
                // Calculate the logical FEN index for this display position
                // When flipped, display position 0 (top-left) should be logical index 63 (h1)
                const logicalIndex = isFlipped ? (63 - displayPos) : displayPos;
                
                // Use logical index for coloring (so board colors stay consistent)
                const row = Math.floor(logicalIndex / 8);
                const col = logicalIndex % 8;
                
                square.classList.add('square');
                if ((row + col) % 2 === 0) {
                    square.classList.add('light');
                } else {
                    square.classList.add('dark');
                }
                // Store the LOGICAL index - this is what we use for moves
                square.dataset.index = logicalIndex;
                square.onclick = () => onSquareClick(logicalIndex);
                chessboard.appendChild(square);
            }
        }

        function renderPieces(boardState) {
            // boardState is a FEN string
            const squares = document.querySelectorAll('.square');
            squares.forEach(s => s.innerHTML = ''); // Clear board
    
            // Using filled pieces for both, but with different colors via CSS
            const pieceMap = {
                'p': '‚ôü', 'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö',  // Black pieces (lowercase in FEN)
                'P': '‚ôü', 'R': '‚ôú', 'N': '‚ôû', 'B': '‚ôù', 'Q': '‚ôõ', 'K': '‚ôö'   // White pieces (uppercase in FEN)
            };
            
            const rows = boardState.split(' ')[0].split('/');
            let logicalIndex = 0;
            
            rows.forEach(row => {
                for (const char of row) {
                    if (isNaN(char)) {
                        // Find square by its logical index (data-index attribute)
                        const square = document.querySelector(`.square[data-index='${logicalIndex}']`);
                        
                        if (square) {
                            const piece = document.createElement('span');
                            piece.classList.add('piece');
                            
                            // Add color class based on piece case (uppercase = white, lowercase = black)
                            if (char === char.toUpperCase()) {
                                piece.classList.add('white-piece');
                            } else {
                                piece.classList.add('black-piece');
                            }
                            
                            piece.textContent = pieceMap[char];
                            square.appendChild(piece);
                        }
                        logicalIndex++;
                    } else {
                        logicalIndex += parseInt(char);
                    }
                }
            });
        }

        let selectedSquare = null;

        function onSquareClick(index) {
            if (selectedSquare === null) {
                // If no piece is selected, select the clicked square if it has a piece
                const square = document.querySelector(`.square[data-index='${index}']`);
                if (square.hasChildNodes()) {
                    selectedSquare = index;
                    square.classList.add('selected');
                }
            } else {
                // If a piece is already selected, this is the destination square
                const from = selectedSquare;
                const to = index;
                const move = {
                    type: 'MOVE',
                    session_id: session_id,
                    game_id: currentGameId, // Assuming currentGameId is stored somewhere
                    move: `${toAlgebraic(from)}${toAlgebraic(to)}`
                };
                send(move);

                // Reset selection
                document.querySelector(`.square[data-index='${from}']`).classList.remove('selected');
                selectedSquare = null;
            }
        }

        function toAlgebraic(index) {
            // Convert logical board index to algebraic notation
            // Index 0 = a8, Index 7 = h8, Index 56 = a1, Index 63 = h1
            const row = 8 - Math.floor(index / 8);
            const col = String.fromCharCode('a'.charCodeAt(0) + (index % 8));
            return `${col}${row}`;
        }

        function updateGameState(gameState) {
            const gameStateDiv = document.getElementById('game-state');
            gameStateDiv.innerHTML = `
                <p id="turn-display"><strong>Turn:</strong> <span id="turn-text">Loading...</span></p>
                <p><strong>White:</strong> ${gameState.white_player}</p>
                <p><strong>Black:</strong> ${gameState.black_player}</p>
            `;
            renderPieces(gameState.board_state);
            // Update turn display if available
            if (gameState.current_turn) {
                updateTurnDisplay(gameState.current_turn);
            }
        }

        function updateTurnDisplay(currentTurn) {
            const turnTextElement = document.getElementById('turn-text');
            if (!turnTextElement) return;
            
            if (currentTurn === myColor) {
                turnTextElement.innerHTML = `<span style="color: #4CAF50; font-weight: bold;">YOUR TURN (${myColor})</span>`;
            } else {
                turnTextElement.innerHTML = `<span style="color: #ff9800;">Opponent's turn (${currentTurn})</span>`;
            }
        }

        function highlightKingInCheck(colorInCheck) {
            clearCheckHighlight();

            // Find the king of the specified color
            // Now both kings use ‚ôö symbol but are distinguished by CSS class
            const kingSymbol = '‚ôö';
            const kingClass = (colorInCheck === 'white') ? 'white-piece' : 'black-piece';

            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                const piece = square.querySelector('.piece');
                if (piece && piece.textContent === kingSymbol && piece.classList.contains(kingClass)) {
                    square.classList.add('in-check');
                    console.log(`Highlighting ${colorInCheck} king in check at square`, square.dataset.index);
                }
            });
        }

        function clearCheckHighlight() {
            document.querySelectorAll('.in-check').forEach(square => {
                square.classList.remove('in-check');
            });
        }

        createChessboard();

        // Start the connection when the page loads
        window.onload = connect;
    </script>
</body>

</html>