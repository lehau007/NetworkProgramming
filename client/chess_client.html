<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Client</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #333;
            color: #fff;
        }

        .container {
            display: flex;
            gap: 20px;
            perspective: 1000px;
        }

        .panel {
            background-color: #444;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.5s, opacity 0.5s;
            width: 350px;
        }

        .hidden {
            display: none;
            opacity: 0;
            transform: rotateY(-30deg) scale(0.9);
        }

        h2 {
            text-align: center;
            color: #4CAF50;
            margin-bottom: 20px;
        }

        input[type="text"],
        input[type="password"],
        input[type="email"] {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 15px;
            border: none;
            border-radius: 5px;
            background-color: #555;
            color: #fff;
        }

        button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 5px;
            background-color: #4CAF50;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            margin-top: 10px;
        }

        button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        #chessboard {
            width: 480px;
            height: 480px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            border: 4px solid #666;
            border-radius: 8px;
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 48px;
            transition: background-color 0.2s;
        }

        .light {
            background-color: #f0d9b5;
        }

        .dark {
            background-color: #b58863;
        }

        .piece {
            cursor: pointer;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .selected {
            background-color: yellow !important;
        }

        .in-check {
            background-color: #ff5252 !important;
            box-shadow: 0 0 20px rgba(255, 82, 82, 0.8) inset;
            animation: pulse-check 1s infinite;
        }

        @keyframes pulse-check {

            0%,
            100% {
                box-shadow: 0 0 20px rgba(255, 82, 82, 0.8) inset;
            }

            50% {
                box-shadow: 0 0 30px rgba(255, 82, 82, 1) inset;
            }
        }

        #player-list div {
            padding: 8px;
            border-bottom: 1px solid #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #player-list button {
            width: auto;
            padding: 5px 10px;
            font-size: 14px;
            margin-top: 0;
        }

        #messages {
            height: 250px;
            overflow-y: auto;
            border: 1px solid #555;
            padding: 10px;
            margin-bottom: 15px;
            background-color: #3a3a3a;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }

        .message {
            padding: 5px;
            border-radius: 3px;
        }

        .system {
            color: #ffab40;
        }

        .sent {
            color: #81d4fa;
        }

        .received {
            color: #c5e1a5;
        }

        #game-state p {
            margin: 5px 0;
        }

        /* User Profile Card */
        .user-profile {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .user-profile h3 {
            margin: 0 0 15px 0;
            color: #fff;
            font-size: 20px;
            text-align: center;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }

        .user-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-box {
            background-color: rgba(255, 255, 255, 0.15);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
        }

        .stat-box.rating {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .stat-box.rating .stat-value {
            font-size: 32px;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Login Section -->
        <div id="login-section" class="panel">
            <h2>Login</h2>
            <input type="text" id="username" placeholder="Username">
            <input type="password" id="password" placeholder="Password">
            <button onclick="login()">Login</button>
            <button onclick="showRegister()">Register</button>
        </div>

        <!-- Register Section -->
        <div id="register-section" class="panel hidden">
            <h2>Register</h2>
            <input type="text" id="reg-username" placeholder="Username">
            <input type="password" id="reg-password" placeholder="Password">
            <input type="email" id="reg-email" placeholder="Email">
            <button onclick="register()">Register</button>
            <button onclick="showLogin()">Back to Login</button>
        </div>

        <!-- Lobby Section -->
        <div id="lobby-section" class="panel hidden">
            <h2>Lobby</h2>

            <!-- User Profile Card -->
            <div class="user-profile">
                <h3>üèÜ <span id="profile-username">Player</span></h3>
                <div class="user-stats">
                    <div class="stat-box rating">
                        <div class="stat-label">Rating</div>
                        <div class="stat-value" id="profile-rating">1200</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Wins</div>
                        <div class="stat-value" id="profile-wins">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Losses</div>
                        <div class="stat-value" id="profile-losses">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Draws</div>
                        <div class="stat-value" id="profile-draws">0</div>
                    </div>
                </div>
            </div>

            <div id="player-list"></div>
            <button onclick="getAvailablePlayers()">Refresh Players</button>
            <button onclick="logout()">Logout</button>
        </div>

        <!-- Game Section -->
        <div id="game-section" class="hidden">
            <div class="panel">
                <div id="chessboard"></div>
            </div>
            <div class="panel">
                <h2>Game Info</h2>
                <div id="game-state"></div>
                <div id="messages"></div>
                <button onclick="resign()">Resign</button>
                <button onclick="offerDraw()">Offer Draw</button>
            </div>
        </div>
    </div>

    <script>
        const wsUrl = "ws://localhost:8080";
        let ws = null;
        let session_id = null;
        let username = null;
        let currentGameId = null;
        let userData = null; // Store user data from server
        let myColor = null; // Store player's color ("white" or "black")

        // UI Elements
        const loginSection = document.getElementById('login-section');
        const registerSection = document.getElementById('register-section');
        const lobbySection = document.getElementById('lobby-section');
        const gameSection = document.getElementById('game-section');
        const messagesDiv = document.getElementById('messages');

        // Function to update user profile display
        function updateUserProfile(data) {
            if (!data) return;

            userData = data;
            document.getElementById('profile-username').textContent = data.username || 'Player';
            document.getElementById('profile-rating').textContent = data.rating || '1200';
            document.getElementById('profile-wins').textContent = data.wins || '0';
            document.getElementById('profile-losses').textContent = data.losses || '0';
            document.getElementById('profile-draws').textContent = data.draws || '0';
        }

        // Function to reload user profile from server
        function reloadUserProfile() {
            if (!session_id || !userData || !userData.user_id) return;

            // Request fresh user data from server
            // According to MESSAGE_TYPES.md, we can use VERIFY_SESSION to get updated user_data
            send({ type: 'VERIFY_SESSION', session_id: session_id });
        }

        // UI Navigation
        function showLogin() {
            loginSection.classList.remove('hidden');
            registerSection.classList.add('hidden');
            lobbySection.classList.add('hidden');
            gameSection.classList.add('hidden');
        }

        function showRegister() {
            loginSection.classList.add('hidden');
            registerSection.classList.remove('hidden');
            lobbySection.classList.add('hidden');
            gameSection.classList.add('hidden');
        }

        function showLobby() {
            loginSection.classList.add('hidden');
            registerSection.classList.add('hidden');
            lobbySection.classList.remove('hidden');
            gameSection.classList.add('hidden');
        }

        function showGame() {
            loginSection.classList.add('hidden');
            registerSection.classList.add('hidden');
            lobbySection.classList.add('hidden');
            gameSection.classList.remove('hidden');
        }

        function addMessage(text, type = 'system') {
            const messageDiv = document.createElement('div');
            messageDiv.textContent = text;
            messageDiv.className = type;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function connect() {
            if (ws) {
                ws.close();
            }
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                addMessage("Connected to server.", 'system');
                // If we have a session ID, try to verify it
                const saved_session = localStorage.getItem('session_id');
                if (saved_session) {
                    session_id = saved_session;
                    username = localStorage.getItem('username');
                    send({ type: 'VERIFY_SESSION', session_id: session_id });
                } else {
                    showLogin();
                }
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                addMessage(`Received: ${event.data}`, 'received');
                handleMessage(msg);
            };

            ws.onclose = () => {
                addMessage("Disconnected from server.", 'system');
                ws = null;
                showLogin();
            };

            ws.onerror = (error) => {
                addMessage("WebSocket error.", 'system');
                console.error("WebSocket Error: ", error);
            };
        }

        function send(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const msgString = JSON.stringify(data);
                ws.send(msgString);
                addMessage(`Sent: ${msgString}`, 'sent');
            } else {
                addMessage("Not connected to server.", 'system');
            }
        }

        function handleMessage(msg) {
            switch (msg.type) {
                case 'SESSION_VALID':
                    session_id = msg.session_id;
                    username = msg.user_data.username;
                    localStorage.setItem('session_id', session_id);
                    localStorage.setItem('username', username);

                    // Update user profile with fresh data
                    updateUserProfile(msg.user_data);

                    showLobby();
                    getAvailablePlayers();
                    break;
                case 'SESSION_INVALID':
                    localStorage.removeItem('session_id');
                    localStorage.removeItem('username');
                    session_id = null;
                    username = null;
                    showLogin();
                    break;
                case 'LOGIN_RESPONSE':
                    if (msg.status === 'success') {
                        session_id = msg.session_id;
                        username = msg.user_data.username;
                        localStorage.setItem('session_id', session_id);
                        localStorage.setItem('username', username);

                        // Update user profile with data from login
                        updateUserProfile(msg.user_data);

                        showLobby();
                        getAvailablePlayers();
                    } else {
                        alert(`Login failed: ${msg.message}`);
                    }
                    break;
                case 'REGISTER_RESPONSE':
                    if (msg.status === 'success') {
                        alert('Registration successful! Please login.');
                        showLogin();
                    } else {
                        alert(`Registration failed: ${msg.message}`);
                    }
                    break;
                case 'DRAW_OFFER_RECEIVED':
                    if (confirm('Your opponent has offered a draw. Do you accept?')) {
                        respondToDrawOffer(true);
                    } else {
                        respondToDrawOffer(false);
                    }
                    break;
                case 'MOVE_ACCEPTED':
                    // Update board state if provided
                    if (msg.board_state) {
                        renderPieces(msg.board_state);
                    }
                    // Update game state display
                    if (msg.current_turn) {
                        updateTurnDisplay(msg.current_turn);
                    }
                    // Check if opponent is in check (we just moved)
                    if (msg.is_check && msg.current_turn) {
                        // current_turn is the next player (opponent)
                        // Only highlight if opponent is in check, not us
                        highlightKingInCheck(msg.current_turn);
                        addMessage('‚ö†Ô∏è CHECK! Opponent\'s king is under attack!', 'system');
                    } else {
                        clearCheckHighlight();
                    }
                    break;
                case 'MOVE_REJECTED':
                    alert(`‚ùå Move rejected: ${msg.reason}`);
                    // Clear selection on rejected move
                    if (selectedSquare !== null) {
                        const square = document.querySelector(`.square[data-index='${selectedSquare}']`);
                        if (square) square.classList.remove('selected');
                        selectedSquare = null;
                    }
                    break;
                case 'GAME_ENDED':
                    alert(`Game over: ${msg.reason}`);

                    // Reload user profile to get updated stats (wins/losses/draws/rating)
                    // After game ends, stats are updated on server
                    setTimeout(() => {
                        reloadUserProfile();
                    }, 500);

                    showLobby();
                    break;
                case 'PLAYER_LIST':
                    const playerListDiv = document.getElementById('player-list');
                    playerListDiv.innerHTML = '<h3>Available Players</h3>';
                    msg.players.forEach(player => {
                        if (player.username !== username) {
                            const playerDiv = document.createElement('div');
                            playerDiv.innerHTML = `<span>${player.username} (${player.rating})</span>`;
                            const challengeButton = document.createElement('button');
                            challengeButton.textContent = 'Challenge';
                            challengeButton.onclick = () => challengePlayer(player.username);
                            playerDiv.appendChild(challengeButton);
                            playerListDiv.appendChild(playerDiv);
                        }
                    });
                    break;
                case 'CHALLENGE_RECEIVED':
                    const from = msg.from_username;
                    if (confirm(`You have received a challenge from ${from}. Do you accept?`)) {
                        send({ type: 'ACCEPT_CHALLENGE', session_id: session_id, challenge_id: msg.challenge_id });
                    } else {
                        send({ type: 'DECLINE_CHALLENGE', session_id: session_id, challenge_id: msg.challenge_id });
                    }
                    break;
                case 'MATCH_STARTED':
                    currentGameId = msg.game_id;
                    myColor = msg.your_color; // Save player's color
                    console.log(`Match started! I am playing as ${myColor}`);
                    showGame();
                    send({ type: 'GET_GAME_STATE', session_id: session_id, game_id: msg.game_id });
                    break;
                case 'GAME_STATE':
                    currentGameId = msg.game_id;
                    updateGameState(msg);
                    // Update turn display
                    if (msg.current_turn) {
                        updateTurnDisplay(msg.current_turn);
                    }
                    // Check for check status - only highlight if WE are in check
                    if (msg.is_check && msg.current_turn && msg.current_turn === myColor) {
                        highlightKingInCheck(myColor);
                        addMessage('‚ö†Ô∏è You are in CHECK!', 'system');
                    } else {
                        clearCheckHighlight();
                    }
                    showGame();
                    break;
                case 'OPPONENT_MOVE':
                    updateGameState(msg);
                    // Update turn display
                    if (msg.current_turn) {
                        updateTurnDisplay(msg.current_turn);
                    }
                    // Check if WE are in check (opponent just moved)
                    if (msg.is_check && msg.current_turn) {
                        // current_turn is the next player
                        // If current_turn matches our color, WE are in check
                        if (msg.current_turn === myColor) {
                            highlightKingInCheck(myColor);
                            addMessage('‚ö†Ô∏è You are in CHECK! You must defend your king!', 'system');
                        }
                    } else {
                        clearCheckHighlight();
                    }
                    break;
                default:
                    break;
            }
        }

        function resign() {
            send({
                type: 'RESIGN',
                session_id: session_id,
                game_id: currentGameId
            });
        }

        function offerDraw() {
            send({
                type: 'DRAW_OFFER',
                session_id: session_id,
                game_id: currentGameId
            });
        }

        function respondToDrawOffer(accepted) {
            send({
                type: 'DRAW_RESPONSE',
                session_id: session_id,
                game_id: currentGameId,
                accepted: accepted
            });
        }

        function challengePlayer(targetUsername) {
            send({
                type: 'CHALLENGE',
                session_id: session_id,
                target_username: targetUsername
            });
        }

        function login() {
            const user = document.getElementById('username').value;
            const pass = document.getElementById('password').value;
            if (!user || !pass) {
                alert('Please enter username and password');
                return;
            }
            send({
                type: 'LOGIN',
                username: user,
                password: pass
            });
        }

        function register() {
            const user = document.getElementById('reg-username').value;
            const pass = document.getElementById('reg-password').value;
            const email = document.getElementById('reg-email').value;
            if (!user || !pass) {
                alert('Please enter username and password');
                return;
            }
            send({
                type: 'REGISTER',
                username: user,
                password: pass,
                email: email
            });
        }

        function getAvailablePlayers() {
            if (!session_id) {
                alert('Not logged in');
                return;
            }
            send({
                type: 'GET_AVAILABLE_PLAYERS',
                session_id: session_id
            });
        }

        function logout() {
            if (session_id) {
                send({
                    type: 'LOGOUT',
                    session_id: session_id
                });
            }
            localStorage.removeItem('session_id');
            localStorage.removeItem('username');
            session_id = null;
            username = null;
            currentGameId = null;
            if (ws) {
                ws.close();
            }
            showLogin();
        }




        function createChessboard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';
            for (let i = 0; i < 64; i++) {
                const square = document.createElement('div');
                const row = Math.floor(i / 8);
                const col = i % 8;
                square.classList.add('square');
                if ((row + col) % 2 === 0) {
                    square.classList.add('light');
                } else {
                    square.classList.add('dark');
                }
                square.dataset.index = i;
                square.onclick = () => onSquareClick(i);
                chessboard.appendChild(square);
            }
        }

        function renderPieces(boardState) {
            // boardState is a FEN string
            const squares = document.querySelectorAll('.square');
            squares.forEach(s => s.innerHTML = ''); // Clear board
    
            const pieceMap = {
                'p': '‚ôô', 'r': '‚ôñ', 'n': '‚ôò', 'b': '‚ôó', 'q': '‚ôï', 'k': '‚ôî',
                'P': '‚ôü', 'R': '‚ôú', 'N': '‚ôû', 'B': '‚ôù', 'Q': '‚ôõ', 'K': '‚ôö'
            };
            const rows = boardState.split(' ')[0].split('/');
            let i = 0;
            rows.forEach(row => {
                for (const char of row) {
                    if (isNaN(char)) {
                        const piece = document.createElement('span');
                        piece.classList.add('piece');
                        piece.textContent = pieceMap[char];
                        squares[i].appendChild(piece);
                        i++;
                    } else {
                        i += parseInt(char);
                    }
                }
            });
        }

        let selectedSquare = null;

        function onSquareClick(index) {
            if (selectedSquare === null) {
                // If no piece is selected, select the clicked square if it has a piece
                const square = document.querySelector(`.square[data-index='${index}']`);
                if (square.hasChildNodes()) {
                    selectedSquare = index;
                    square.classList.add('selected');
                }
            } else {
                // If a piece is already selected, this is the destination square
                const from = selectedSquare;
                const to = index;
                const move = {
                    type: 'MOVE',
                    session_id: session_id,
                    game_id: currentGameId, // Assuming currentGameId is stored somewhere
                    move: `${toAlgebraic(from)}${toAlgebraic(to)}`
                };
                send(move);

                // Reset selection
                document.querySelector(`.square[data-index='${from}']`).classList.remove('selected');
                selectedSquare = null;
            }
        }

        function toAlgebraic(index) {
            const row = 8 - Math.floor(index / 8);
            const col = String.fromCharCode('a'.charCodeAt(0) + (index % 8));
            return `${col}${row}`;
        }

        function updateGameState(gameState) {
            const gameStateDiv = document.getElementById('game-state');
            gameStateDiv.innerHTML = `
                <p id="turn-display"><strong>Turn:</strong> <span id="turn-text">Loading...</span></p>
                <p><strong>White:</strong> ${gameState.white_player}</p>
                <p><strong>Black:</strong> ${gameState.black_player}</p>
            `;
            renderPieces(gameState.board_state);
            // Update turn display if available
            if (gameState.current_turn) {
                updateTurnDisplay(gameState.current_turn);
            }
        }

        function updateTurnDisplay(currentTurn) {
            const turnTextElement = document.getElementById('turn-text');
            if (!turnTextElement) return;
            
            if (currentTurn === myColor) {
                turnTextElement.innerHTML = `<span style="color: #4CAF50; font-weight: bold;">YOUR TURN (${myColor})</span>`;
            } else {
                turnTextElement.innerHTML = `<span style="color: #ff9800;">Opponent's turn (${currentTurn})</span>`;
            }
        }

        function highlightKingInCheck(colorInCheck) {
            clearCheckHighlight();

            // Find the king of the specified color
            // White king (solid) = '‚ôî', Black king (hollow) = '‚ôö'
            const squares = document.querySelectorAll('.square');
            const whiteKingSymbol = '‚ôö';  // Solid white king
            const blackKingSymbol = '‚ôî';  // Hollow black king
            const kingSymbol = (colorInCheck === 'white') ? whiteKingSymbol : blackKingSymbol;

            squares.forEach(square => {
                const piece = square.querySelector('.piece');
                if (piece && piece.textContent === kingSymbol) {
                    square.classList.add('in-check');
                    console.log(`Highlighting ${colorInCheck} king in check at square`, square.dataset.index);
                }
            });
        }

        function clearCheckHighlight() {
            document.querySelectorAll('.in-check').forEach(square => {
                square.classList.remove('in-check');
            });
        }

        createChessboard();

        // Start the connection when the page loads
        window.onload = connect;
    </script>
</body>

</html>